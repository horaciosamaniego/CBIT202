[["index.html", "Diapositivas CBIT202 Capítulo 1 Datos del curso (CBIT202-23) 1.1 DESCRIPCIÓN DEL CURSO 1.2 Evaluación 1.3 Calendario 1.4 Recursos adicionales", " Diapositivas CBIT202 Horacio Samaniego 2025-08-07 Capítulo 1 Datos del curso (CBIT202-23) Universidad Austral de Chile: Laboratorio de Ecoinformatica Nombre asignatura: Introducción al Análisis de Datos Geoespaciales Código asignatuta: CBIT202-23 Docente responsable: Horacio Samaniego Correo electrónico: horaciosamaniego@uach.cl Modalidad de clases: Prácticas Presenciales Consultas por Discord (chat o video) - Horario de clases: Lunes 9:50 - 13:00 hrs Lugar: Sala de computación, Facultad de Ciencias Forestales y Recursos Naturales, Campus Isla Teja, Valdivia Inicio clases: 11 agosto 2025 Pausa lectiva 13 - 17 Octubre 2025 Término clases: 28 noviembre 2025 (puede modificarse según calendario académico) 1.1 DESCRIPCIÓN DEL CURSO Este curso tiene como objetivo central adquirir herramientas para el manejo de datos con un énfasis en datos espaciales para el menejo de los recursos naturales y la aproximación y resolución de problemas ambientaleslos. Se busca la creación de competencias en los principios de investigación reproducible, representación y análisis de información espacial y la creación de mapas estáticos e interactivos. Esto permitirá la adquisiciónde herramientas para profundizar el conocimientos acerca del diseño y desarrollo de análisis de datos ambientales complejos y espacialmente explícitos. 1.1.1 OBJETIVOS Conocer y entender el concepto de Investigación Reproducible como una forma y filosofía de trabajo que permite que las investigaciones sean más ordenadas y replicables, desde la toma de datos hasta la escritura de resultados utilizando R. Realizar análisis críticos de la naturaleza de los datos al realizar análisis exploratorios y reforzar conociminetos en estadística. Realizar análisis de datos espaciales, poder hacer mapas y aplicar a preguntas de conservación y manejo de recursos naturales. Aprender a utilizar de forma proficiente el lenguaje de programación R y la plataforma GitHub en un ambiente de trabajo colaborativo. 1.2 Evaluación 1.2.1 Tareas Se entregarán ejercicios semanales que deben ser resueltos. 1.2.2 proyectos Se desarrollán proyectos de análisis y de programación que consistirán en la resolución de un problema, o set de preguntas. 1.2.3 calificaciones .calificaciones {width: 35%; left: 50%} Evaluación Ponderación Ejercicios &amp; Tareas \\[\\frac{1}{n}\\sum_i^n nota\\, tarea_i\\] 50% Proyecto código 1 15% Proyecto código 2 25% Participación / Asistencia 10% 1.3 Calendario 1.3.1 Módulo 1: Introducción a R y RStudio 18 Agosto — Presentación del curso R como lenguaje de programación para análisis de datos Entorno de RStudio: navegación básica y gestión del espacio de trabajo Tipos y estructuras de datos: vectores, matrices, data frames y tibbles Operaciones aritméticas y lógicas básicas Introducción a paquetes y gestión de paquetes 1.3.2 Módulo 2: HTML, Markdown &amp; R 18 Agosto — Introducción a Markdown y R Markdown Creación de informes reproducibles Sintaxis Markdown Incorporación de fragmentos de código R Formatos de salida (HTML, PDF, Word) Investigación reproducible 1.3.3 Módulo 3: Manipulación de Datos con Tidyverse 25 Agosto — datos desde varios formatos (CSV, Excel, bases de datos, etc.) Introducción a tidyverse Importación y Exportación de Datos Manejo de valores faltantes Limpieza y preprocesamiento de datos 1 Septiembre — Manejo y Análisis de datos Manipulación de datos con dplyr: select, filter, arrange, mutate, group_by, summarize Tabulaciones Ordenación de datos con tidyr: gather, spread, separate, unite Transformación de datos con purrr: programación funcional para análisis de datos 8 Septiembre — Análisis y comunicación de resultados 1.3.4 Modulo 5: Visualización de Datos 15 Septiembre — Introducción a ggplot2 Creación de diversos tipos de gráficos (diagramas de dispersión, histogramas, diagramas de caja, gráficos de barras, gráficos de líneas) Personalización de gráficos con estética, escalas y temas Facetas y capas de gráficos 22 Septiembre — Visualización Visualización interactiva Mapview 29 Septiembre — Presentación de resolución de problema en 3’+2’ Presentación en ppt (markdown) Resultados y Discusión 1.3.5 Módulo 6: Introducción al Análisis Geoespacial 6 Octubre — Introducción a los datos espaciales Lectura y escritura de datos espaciales (shapefiles, GeoJSON, etc.) Definir y transformar proyecciones Operaciones espaciales básicas (unión, intersección, búfer) Análisis de datos espaciales 13 Octubre — (Semana de receso) 10 20 Octubre — datos en grilla - Fuentes y formatos - filtros y procesamiento - algebra de mapa - mapas categóricos, clasificación y reclasificación 27 Octubre — Mapas - Cartografía - Mapas de distintas fuentes - Mapas interactivos, mapview y leaflet 3 Noviembre — Operaciones de grillas Operaciones espaciales conjuntas: puntos, vectores y grillas Tabular informacion raster interpolaciones 10 Noviembre — Proyectos 17 Noviembre — Proyectos 24 Noviembre — Proyectos 1.4 Recursos adicionales Si bien intentamos buscar ejemplos originales y sets de datos locales, gran parte del material con que trabajaremos ha sido ya trabajado elaborado por otros. Es por eso que se sugiere revisar algunos sitios claves como los siguientes: R for Data Sciences Stackoverflow GIS Stack Exchange Spatial Data Science R Graph Gallery ggplot2 tips "],["ejercicios-y-proyectos.html", "Capítulo 2 Ejercicios y Proyectos 2.1 Tareas semanales 2.2 Descargar Ejercicios 2.3 Proyecto", " Capítulo 2 Ejercicios y Proyectos 2.1 Tareas semanales Una de las evaluacines de este curso consta de pequeñas guías de ejercicios de caracter semanal. Estas representan un 50% de la nota final. Podra encontrar, en la medida que se liberen, los links a las mismas a continuación. Los archivos que esten en formato Rmd se desplegaran como un archivo de texto, compie este texto en un archivo Rmd en su R Studio. 2.2 Descargar Ejercicios Tareas 1: Conseptos basicos de programación en R. LINK TAREA 1 PDF Tareas 2: Conseptos basicos de programación en R. LINK TAREA 2 PDF. Tareas 3: Conseptos basicos de programación en R. LINK TAREA 3 RMD O ejecute el siguiente código para descargar el archivo en su working directory githubURL &lt;- &#39;https://raw.githubusercontent.com/CBIT202-18-Analisis-de-datos-geo/Ejercicios_CBIT202/main/RMarkdown/Ejercicios_3_CBIT202_R.Rmd&#39; download.file(githubURL, &quot;Ejercicios_3_CBIT202_R.Rmd&quot;) Tareas 4: Conseptos basicos de programación en R. LINK TAREA 4 RMD O ejecute el siguiente código para descargar el archivo en su working directory githubURL &lt;- &#39;https://raw.githubusercontent.com/CBIT202-18-Analisis-de-datos-geo/Ejercicios_CBIT202/blob/main/RMarkdown/Ejercicios_4_CBIT202.Rmd&#39; download.file(githubURL, &quot;Ejercicios_4_CBIT202_R.Rmd&quot;) 2.3 Proyecto LINK PROYECTO "],["introducción.html", "Capítulo 3 Introducción 3.1 Objetos 3.2 Variables 3.3 Funciones 3.4 Vectores 3.5 Instalar librerías 3.6 R Notebook 3.7 Leer datos 3.8 Ejercicios", " Capítulo 3 Introducción R es un entorno y lenguaje de programación con un enfoque al análisis estadístico. Permite hacer todos los análisis numéricos que requieras en tu vida profesional. Es una implementación de libre distribución de otro programa estadístico de uso comercial, S. Al ser software libre, es la comunidad de usuarios la que guía su desarrollo, transformándolo en uno de los programas más versátiles para trabajos cuantitativos existentes hoy en día. La página principal desde la que se puede acceder a los archivos y documentación necesarias para su utilización es: www.r-project.org Si bien R es un software que puede usarse desde la línea de comando, para trabajar utilizaremos http://www.rstudio.org. Este es un Entorno de Desarrollo Integrado (IDE, por su sigla en inglés) que, al igual que R, es software libre y permite integrar herramientas necesarias para el desarrollo y así facilitarlo. La página oficial para descargarlo es: www.rstudio.com 3.1 Objetos En términos genéricos, todos los elementos que R maneja son objetos. Un objeto tiene ciertas propiedades y en ocasiones es capaz de llevar a cabo ciertas tareas si se le dan los argumentos necesarios. Por ejemplo, un teléfono es capaz de realizar llamadas siempre que le demos el número a marcar. 3.2 Variables Al momento de trabajar, es probable que necesitemos guardar valores o cálculos, de manera que no necesitemos escribirlos cada vez que los usemos, para esto utilizamos variables. Para realizar una asignación de variable: a = 200 Luego, podemos utilizar el valor contenido en la variable, utilizando su nombre: print(a) #&gt; [1] 200 3.2.1 Tipos de variables Existen diversos tipos o clases de variables, dependiendo de las características del objeto que les es asignado. Para conocer a qué tipo corresponde un objeto usamos class: x=7 x #&gt; [1] 7 class (x) #&gt; [1] &quot;numeric&quot; x=5/3 x #&gt; [1] 1.666667 class (x) #&gt; [1] &quot;numeric&quot; x=&quot;Trece&quot; x #&gt; [1] &quot;Trece&quot; class (x) #&gt; [1] &quot;character&quot; 3.3 Funciones Muchas cosas en R pueden hacerse a través del uso de funciones, estas permiten realizar operaciones típicas sin necesidad de escribir grandes cantidades de código. Por ejemplo: sqrt(10) #&gt; [1] 3.162278 round(1.9) #&gt; [1] 2 seq(0,10) #&gt; [1] 0 1 2 3 4 5 6 7 8 9 10 seq(0,10,2) #&gt; [1] 0 2 4 6 8 10 rep(5,10) #&gt; [1] 5 5 5 5 5 5 5 5 5 5 paste(seq(5,10), &quot;elefantes&quot;) #&gt; [1] &quot;5 elefantes&quot; &quot;6 elefantes&quot; &quot;7 elefantes&quot; #&gt; [4] &quot;8 elefantes&quot; &quot;9 elefantes&quot; &quot;10 elefantes&quot; Los datos o variables que van dentro de las funciones, se denominan argumentos y cada función requiere que se le entreguen los argumentos apropiados para ejecutar la acción prevista. Por ejemplo, la función mean() no puede calcular el promedio si como argumentos se le pasan letras. mean(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) #&gt; Warning in mean.default(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)): argument is not #&gt; numeric or logical: returning NA #&gt; [1] NA Esto es importante, porque al introducir datos podemos estar utilizando números como palabras: 1, 2, 3 ≠ “1”, “2”, “3” Si nos encontramos con este problema, debemos transformar los datos al tipo o clase adecuada, con las funciones: as.numeric() y as. character()x` 3.4 Vectores Conjunto ordenado de valores del mismo tipo, agrupados en un único objeto. Para crear una variable vector utilizamos: v = c(1,1,2,3) vector = c(&quot;mi&quot;, &quot;primer&quot;, &quot;vector&quot;) vector #&gt; [1] &quot;mi&quot; &quot;primer&quot; &quot;vector&quot; Cada objeto dentro de un vector posee un índice, el cual indica la posición que ocupa dentro del vector, para acceder a una posición específica usamos: vector[1] #&gt; [1] &quot;mi&quot; vector[2] #&gt; [1] &quot;primer&quot; vector[3] #&gt; [1] &quot;vector&quot; y si queremos reemplazar alguno de esos objetos: vector[2]=&quot;segundo&quot; vector #&gt; [1] &quot;mi&quot; &quot;segundo&quot; &quot;vector&quot; Un vector permite almacenar varios valores en una única variable y permite ejecutar operaciones o funciones a un conjunto de datos: vector = c(1,2,3,4,5) vector*2 #&gt; [1] 2 4 6 8 10 vector^2 #&gt; [1] 1 4 9 16 25 o incluso realizar operaciones entre vectores: v1=c(1:3) v2=c(6,8,10) v1 #&gt; [1] 1 2 3 v2 #&gt; [1] 6 8 10 v1 + v2 #&gt; [1] 7 10 13 v1*v2 #&gt; [1] 6 16 30 v3=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) v1 * v3 #&gt; Error in v1 * v3: non-numeric argument to binary operator 3.5 Instalar librerías Muchas veces las funciones incorporadas en R son insuficientes para nuestros fines, por lo que es necesario instalar paquetes o “packages” de herramientas hechas por la comunidad. En este caso, usaremos el paquete “openxlsx”, que nos permite leer archivos Excel. Para instalarlo: install.packages(&quot;openxlsx&quot;) Debe hacerse una única vez, los paquetes quedan instalados en nuestra versión de R. Y para usarlo dentro de nuestro proyecto: library(openxlsx) Debe incluirse en cada proyecto donde queramos usarlo y ejecutarse cada vez que abrimos R. 3.6 R Notebook Un Notebook en R es un documento con bloques o “chunks” que pueden ser ejecutados directa e interactivamente, para así visualizar los resultados directamente bajo el código. Para instalar esta librería: install.packages(&quot;rmarkdown&quot;) Una vez instalada, puedes crear un nuevo notebook en RStudio llendo a File -&gt; new file -&gt; R notebook. Agrega un nuevo chunk haciendo click en el botón Insert Chunk en la barra de herramientas o presionando Ctrl+Alt+I Un chunk puede ser ejecutado usando: Haciendo click en el triángulo verde o “Run Current Chunk” en la esquina superior derecha de cada chunk. Clickeando al interior de un chunk y presionando Ctrl + Enter. De ambas formas se ejecutará todo el código contenido dentro de el chunk. Cuando guardas ul notebook, un archivo HTML que contiene el código y los resultados se guardará junto a él (Click en el botón de Preview o presiona Ctrl+Shift+K para previsualizar el archivo HMTL) 3.7 Leer datos Delimitados por coma: read_csv(“file.csv”) Con cualquier delimitador: read_delim(“file.txt”, delim = “|”) 3.8 Ejercicios Cree una nueva variable que contenga un vector con 10 números aleatorios multiplíquela por seis. cree una segunda variable que contenga una secuencia de 5 caracteres combine las dos variable en una sola variable ¿cuál es el largo de esta última variable creada? ¿de qué tipo es esta variable? ¿qué sucede si divie esta última variable por 3? cree un vector con los elementos 1 2 3 4 5 6 y llámelo x cree un nuevo vector con los elementos 10 20 30 40 50 y llámelo y ¿qué ocurre si intenta sumar x e y? explique agregue el valor 60 al vector y (ayuda: puedes usar la función c()) sume x e y multiplique x e y cree un data.frame con el mímimo código posible usando los datos de la siguiente imagen y llámelo z: cree un dataframe de datos ficticios que represente una muestra de 100 individuos de aves y su tamaño corporal. Use 4 tipos de aves: un paseriforme, un columbiforme, un rapaz y trochiliformes en aproximadamente las mismas proporciones. (Averigue el real tamaño promedio de cada grupo) grafique los pesos corporales de cada grupo (ayuda: puede usar graficos de distribuciones, caja y bigote o bien de violín) "],["principios-de-tidydata.html", "Capítulo 4 Principios de Tidydata 4.1 Definiciones 4.2 Lógica y funciones 4.3 Cambiar formato de tabla 4.4 Ejercicio 4.5 Bonus (Esto requiere investigar no basta con lo que aprendimos) 4.6 Recursos", " Capítulo 4 Principios de Tidydata Gran parte del manejo de datos consiste en limpiar, ordenar, redistribuir, reemplazar datos. La gran mayoría de esas tareas son complejas y repetitivas. La documentación dice aqui que: Los principios de tidydata (datos ordenados, en castellano) proporcionan una forma estándar de organizar los valores de los datos dentro de un conjunto de datos. Un estándar facilita la limpieza inicial de los datos, ya que no es necesario empezar de cero y reinventar la rueda cada vez. El estándar tidydata se ha diseñado para facilitar la exploración y el análisis de los datos, y para simplificar el desarrollo de herramientas de análisis de datos que funcionen bien juntas. Las herramientas actuales suelen requerir traducción. Hay que dedicar tiempo a procesar los resultados de una herramienta para poder introducirlos en otra. Los conjuntos de datos ordenados y las herramientas ordenadas trabajan codo a codo para facilitar el análisis, lo que permite centrarse en la parte interesante del problema, no en lo “aburrido” de la logística de los datos. 4.1 Definiciones En el manejo estadístico de los datos estructuramos, usualmente, con tablas (dataframes) con filas y columnas. Las columnas siempre tienen títulos, aunque las filas solo a veces. Elementos de una tabla Usemos el set de datos de ejemplo llamado iris, pero le vamos a agregar un año de colecta ficticio. Para eso, vamos a crear un vector con 3 fechas asignadas de forma aleatoria a cada fila. Veamos las primeras 7 filas con la función head(). data(iris) año &lt;- sample(rep(c(&quot;2003&quot;,&quot;2013&quot;,&quot;2023&quot;), nrow(iris) / 3)) iris$Año &lt;- año kableExtra::kable(head(iris,7)) Sepal.Length Sepal.Width Petal.Length Petal.Width Species Año 5.1 3.5 1.4 0.2 setosa 2003 4.9 3.0 1.4 0.2 setosa 2023 4.7 3.2 1.3 0.2 setosa 2023 4.6 3.1 1.5 0.2 setosa 2023 5.0 3.6 1.4 0.2 setosa 2013 5.4 3.9 1.7 0.4 setosa 2013 4.6 3.4 1.4 0.3 setosa 2003 4.2 Lógica y funciones La lógica básica para el manejo de datos usando dplyr es que el resultado de una operación puede ser “conectada” a otra, lo que facilita la letura del código cuando lo revisitamos. Para eso existe una operador que hace esta conexión. 4.2.1 Funciones esenciales pipe: |&gt; group_by (agrupa datos) summarize (resume datos agrupados) filter (Encuentra filas con ciertas condiciones) select junto a starts_with, ends_with o contains mutate (Genera variables nuevas) arrange ordenar 4.2.2 pipe Esta “conexión”, se hace con este operador %&gt;% o bien |&gt;. La diferencia entre los dos es que el uso del segundo no debieras requerir pre cargar la librería y es de uso mas reciente. por ejemplo, podemos calcular el largo promedio de los petalos de las especie en el set de datos iris. library(dplyr) iris |&gt; group_by(Species) |&gt; summarize(Promedio=mean(Petal.Length)) #&gt; # A tibble: 3 × 2 #&gt; Species Promedio #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 setosa 1.46 #&gt; 2 versicolor 4.26 #&gt; 3 virginica 5.55 4.2.3 Agrupar dplyr provee un set acotado de funciones, pero muy poderosas para manejar y ordenarnos con los datos. El ejemplo anterior muestra como se conecta una función con otra. Lo primero que hace es definir la tabla sobre la que vamos a trabajar, iris. Esta tabla es luego agrupada por la columna Species que es finalmente usada en la función summarize para calcular la media sobre los groupos de filas para cada especie. De forma similar, podriamos también buscar la varianza de todas las columnas que son de tipo numérico, adjuntar una columna con el número de filas sobre el que calculamos dicha varianza y luego imprimirla a la pantalla de forma mas estilizada. iris |&gt; group_by(Species) |&gt; summarise(across(where(is.numeric), var, na.rm = TRUE), N = n())|&gt; kableExtra::kable() |&gt; kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), full_width = F) Species Sepal.Length Sepal.Width Petal.Length Petal.Width N setosa 0.1242490 0.1436898 0.0301592 0.0111061 50 versicolor 0.2664327 0.0984694 0.2208163 0.0391061 50 virginica 0.4043429 0.1040041 0.3045878 0.0754327 50 4.2.4 Filtrar Filter nos permite encontrar, y operar, solo sobre filas que cumplen una condición determinada. Por ejemplo solo un tipo de especie iris |&gt; filter(Species == &#39;virginica&#39;) |&gt; kableExtra::kable() |&gt; kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), full_width = F) |&gt; kableExtra::scroll_box(height = &quot;250px&quot;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species Año 6.3 3.3 6.0 2.5 virginica 2013 5.8 2.7 5.1 1.9 virginica 2013 7.1 3.0 5.9 2.1 virginica 2013 6.3 2.9 5.6 1.8 virginica 2023 6.5 3.0 5.8 2.2 virginica 2023 7.6 3.0 6.6 2.1 virginica 2013 4.9 2.5 4.5 1.7 virginica 2023 7.3 2.9 6.3 1.8 virginica 2003 6.7 2.5 5.8 1.8 virginica 2023 7.2 3.6 6.1 2.5 virginica 2023 6.5 3.2 5.1 2.0 virginica 2003 6.4 2.7 5.3 1.9 virginica 2023 6.8 3.0 5.5 2.1 virginica 2003 5.7 2.5 5.0 2.0 virginica 2003 5.8 2.8 5.1 2.4 virginica 2013 6.4 3.2 5.3 2.3 virginica 2023 6.5 3.0 5.5 1.8 virginica 2003 7.7 3.8 6.7 2.2 virginica 2003 7.7 2.6 6.9 2.3 virginica 2013 6.0 2.2 5.0 1.5 virginica 2003 6.9 3.2 5.7 2.3 virginica 2023 5.6 2.8 4.9 2.0 virginica 2003 7.7 2.8 6.7 2.0 virginica 2013 6.3 2.7 4.9 1.8 virginica 2023 6.7 3.3 5.7 2.1 virginica 2023 7.2 3.2 6.0 1.8 virginica 2013 6.2 2.8 4.8 1.8 virginica 2013 6.1 3.0 4.9 1.8 virginica 2013 6.4 2.8 5.6 2.1 virginica 2013 7.2 3.0 5.8 1.6 virginica 2013 7.4 2.8 6.1 1.9 virginica 2013 7.9 3.8 6.4 2.0 virginica 2003 6.4 2.8 5.6 2.2 virginica 2003 6.3 2.8 5.1 1.5 virginica 2003 6.1 2.6 5.6 1.4 virginica 2023 7.7 3.0 6.1 2.3 virginica 2003 6.3 3.4 5.6 2.4 virginica 2023 6.4 3.1 5.5 1.8 virginica 2003 6.0 3.0 4.8 1.8 virginica 2013 6.9 3.1 5.4 2.1 virginica 2023 6.7 3.1 5.6 2.4 virginica 2003 6.9 3.1 5.1 2.3 virginica 2003 5.8 2.7 5.1 1.9 virginica 2003 6.8 3.2 5.9 2.3 virginica 2003 6.7 3.3 5.7 2.5 virginica 2023 6.7 3.0 5.2 2.3 virginica 2023 6.3 2.5 5.0 1.9 virginica 2003 6.5 3.0 5.2 2.0 virginica 2003 6.2 3.4 5.4 2.3 virginica 2023 5.9 3.0 5.1 1.8 virginica 2013 Debemos tener en cuenta que si usamos filter tendremos que siempre tener un operador en el argumento de la función. En este caso era el operado == que es un igual, pero de forma literal, no como una asignación. Otro ejemplo podría ser seleccionar aquellas filas que tengan un largo de petalos mayor a 4.5, por ejemplo iris |&gt; filter(Petal.Length &gt; 4.5) |&gt; kableExtra::kable() |&gt; kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), full_width = F) |&gt; kableExtra::scroll_box(height = &quot;250px&quot;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species Año 7.0 3.2 4.7 1.4 versicolor 2013 6.9 3.1 4.9 1.5 versicolor 2003 6.5 2.8 4.6 1.5 versicolor 2023 6.3 3.3 4.7 1.6 versicolor 2003 6.6 2.9 4.6 1.3 versicolor 2013 6.1 2.9 4.7 1.4 versicolor 2003 5.9 3.2 4.8 1.8 versicolor 2023 6.3 2.5 4.9 1.5 versicolor 2013 6.1 2.8 4.7 1.2 versicolor 2023 6.8 2.8 4.8 1.4 versicolor 2013 6.7 3.0 5.0 1.7 versicolor 2003 6.0 2.7 5.1 1.6 versicolor 2023 6.7 3.1 4.7 1.5 versicolor 2023 6.1 3.0 4.6 1.4 versicolor 2003 6.3 3.3 6.0 2.5 virginica 2013 5.8 2.7 5.1 1.9 virginica 2013 7.1 3.0 5.9 2.1 virginica 2013 6.3 2.9 5.6 1.8 virginica 2023 6.5 3.0 5.8 2.2 virginica 2023 7.6 3.0 6.6 2.1 virginica 2013 7.3 2.9 6.3 1.8 virginica 2003 6.7 2.5 5.8 1.8 virginica 2023 7.2 3.6 6.1 2.5 virginica 2023 6.5 3.2 5.1 2.0 virginica 2003 6.4 2.7 5.3 1.9 virginica 2023 6.8 3.0 5.5 2.1 virginica 2003 5.7 2.5 5.0 2.0 virginica 2003 5.8 2.8 5.1 2.4 virginica 2013 6.4 3.2 5.3 2.3 virginica 2023 6.5 3.0 5.5 1.8 virginica 2003 7.7 3.8 6.7 2.2 virginica 2003 7.7 2.6 6.9 2.3 virginica 2013 6.0 2.2 5.0 1.5 virginica 2003 6.9 3.2 5.7 2.3 virginica 2023 5.6 2.8 4.9 2.0 virginica 2003 7.7 2.8 6.7 2.0 virginica 2013 6.3 2.7 4.9 1.8 virginica 2023 6.7 3.3 5.7 2.1 virginica 2023 7.2 3.2 6.0 1.8 virginica 2013 6.2 2.8 4.8 1.8 virginica 2013 6.1 3.0 4.9 1.8 virginica 2013 6.4 2.8 5.6 2.1 virginica 2013 7.2 3.0 5.8 1.6 virginica 2013 7.4 2.8 6.1 1.9 virginica 2013 7.9 3.8 6.4 2.0 virginica 2003 6.4 2.8 5.6 2.2 virginica 2003 6.3 2.8 5.1 1.5 virginica 2003 6.1 2.6 5.6 1.4 virginica 2023 7.7 3.0 6.1 2.3 virginica 2003 6.3 3.4 5.6 2.4 virginica 2023 6.4 3.1 5.5 1.8 virginica 2003 6.0 3.0 4.8 1.8 virginica 2013 6.9 3.1 5.4 2.1 virginica 2023 6.7 3.1 5.6 2.4 virginica 2003 6.9 3.1 5.1 2.3 virginica 2003 5.8 2.7 5.1 1.9 virginica 2003 6.8 3.2 5.9 2.3 virginica 2003 6.7 3.3 5.7 2.5 virginica 2023 6.7 3.0 5.2 2.3 virginica 2023 6.3 2.5 5.0 1.9 virginica 2003 6.5 3.0 5.2 2.0 virginica 2003 6.2 3.4 5.4 2.3 virginica 2023 5.9 3.0 5.1 1.8 virginica 2013 4.2.5 Crear nuevas variables Con mutate() podemos crear una nueva columna de forma explícita. Por ejemplo, si quisieramos saber cuales son las especies y años en que se colectaron especies con una razon largo/ancho determinado. iris |&gt; mutate(Petal.Ratio = Petal.Length/Petal.Width)|&gt; select(Petal.Ratio,Species,Año) |&gt; group_by(Species,Año) |&gt; summarize(Petal.Ratio.Mean = mean(Petal.Ratio)) |&gt; filter(Petal.Ratio.Mean &gt; median(Petal.Ratio.Mean)) #&gt; `summarise()` has grouped output by &#39;Species&#39;. You can #&gt; override using the `.groups` argument. #&gt; # A tibble: 3 × 3 #&gt; # Groups: Species [3] #&gt; Species Año Petal.Ratio.Mean #&gt; &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 setosa 2003 7.75 #&gt; 2 versicolor 2013 3.35 #&gt; 3 virginica 2013 2.88 4.2.6 Responder: ¿Escriba la pregunta que responde el análisis? En función del último análisis, ¿existe diferencia interespecífica en la relación entre largo y ancho largo para estes grupo de especies? -¿Cómo formularías la pregunta anterior de forma mas precisa en función del análisis anterior? 4.3 Cambiar formato de tabla Muchas veces es necesario reorientar la tabla de datos. Primero, podríamos interesarnos en definir clases para las muestras. Definimos tamaños como clases usando terciles. etiquetas &lt;- c(&quot;alto&quot;,&quot;medio&quot;,&quot;bajo&quot;) miIris &lt;- iris |&gt; mutate(Tamaño = factor(ntile(Petal.Length/Petal.Width,3),ordered = TRUE, labels = etiquetas)) Luego vamos a re-orientar la tabla de manera a poder indagar si existe diferencia entre especies respecto de la característica Tamaño miIris |&gt; select(Species, Año,Tamaño,Sepal.Width) |&gt; tidyr::pivot_wider(names_from = Tamaño, values_from = Sepal.Width,values_fn=mean) |&gt; kableExtra::kable() Species Año bajo medio alto setosa 2003 3.393333 3.300000 NA setosa 2023 3.268750 3.900000 3.500000 setosa 2013 3.540000 4.400000 NA versicolor 2013 2.200000 2.686667 2.733333 versicolor 2003 2.700000 2.857143 3.000000 versicolor 2023 2.800000 2.683333 3.033333 virginica 2013 NA 2.960000 2.900000 virginica 2023 2.600000 2.700000 3.107692 virginica 2003 NA 2.966667 2.976923 4.3.1 ¿Podemos explicar que sucedió aquí? ¿En qué caso aparecen los NA? ¿Qué tipo de gráfico evidenciaría la relación entre el ratio largo:ancho del pétalo y el ancho del sépalo? grafica 4.4 Ejercicio Usando la base de datos del repositorio del ministerio de ciencias, genera un dataframe que responda lo siguiente: url &lt;- &quot;https://raw.githubusercontent.com/MinCiencia/Datos-COVID19/master/output/producto19/CasosActivosPorComuna_std.csv&quot; Casos_Activos &lt;- read_csv(url) ¿Qué proporción de las comunas ha tenido en algún momento más de 50 casos por cada 100.000 habitantes? Genera un dataframe, donde aparezca para cada comuna que haya tenido sobre 50 casos por cada 100.000 habitantes, cuantos días ha tenido sobre ese valor. Genera una tabla con las comunas que han tenido sobre 50 casos por cada 100.000 habitantes y de esas comunas crea una variable que sea la prevalencia máxima de dicha comuna. 4.5 Bonus (Esto requiere investigar no basta con lo que aprendimos) Ve cuales son las 10 comunas que han tenido la mayor mediana de prevalencia, para cada una de estas 10 comunas, genera una tabla con la mediana, prevalencia máxima y fecha en que se alcanzó la prevalencia máxima La prevalencia es la proporción de la población afectada en un período de tiempo determinado. 4.6 Recursos data wrangling cheatsheet tablas “bonitinhas” con Kable "],["rmarkdown.html", "Capítulo 5 RMarkdown 5.1 ¿Qué es R Markdown? 5.2 Librerías 5.3 Crear un R Markdown 5.4 Encabezado YAML 5.5 Sintáxis de Markdown 5.6 MD -&gt; HTML 5.7 Código R 5.8 Recursos", " Capítulo 5 RMarkdown 5.1 ¿Qué es R Markdown? 5.2 Librerías # install.packages(&quot;rmarkdown&quot;) library(rmarkdown) 5.3 Crear un R Markdown 5.4 Encabezado YAML El archivo .Rmd comienza con una sección que definie los parámetros con que se va a compilar este .Rmd. En general, usa un lenguaje de serialización que sirve para definir configuraciones. --- title: &quot;Informe de Biodiversity&quot; author: Juan Pérez date: 21/Oct/2024 output: html_document --- La línea importante es la del output, pues indica el tipo de archivo que se producirá al compilar este .Rmd. Intentaremos usar HTML como output en cuánto se pueda. Es lo mas sencillo y liviano, puede verse en el navegador. Otra posibildad es usar PDF, pero eso requiere tener instaladas librerías que compilen un archivo LaTeX. 5.5 Sintáxis de Markdown Markdown es un lenguaje parecido a html que permite dar un ormato simplificado a documentos de texto. Puedes encontrar distintos recursos con ayudas para recordar como usarlo. Markdown Cheatsheet 5.5.1 Lo esencial Lo mas simple es los siguiente: Títulos y subtítulos: se escriben con #, pueden haber hasta 4 niveles de subtítulos Enlaces: [texto a linkear](http://wwww.ENLACE.cl) Negritas: flankear texto con **, asi **negrita** Itálica: flankear texto con solo un asterisco: * 5.5.2 Listas Existen 2 tipos de listas, las numeradas y las que no. Listas numeradas: Iniciar frase con un número seguido por un punto. Primer elemento Segundo… Listas simples: iniciar frase con un guión seguido por un espacio. elemento de list otro elemento 5.5.3 Mostrar ejemplos de de código (sin ejecutarlos) Los pedazos de código en la sección de text (no del chunk!) irán flankeadas por cremilla inversa `. Habrán veces en que necesitaremos no solo mostrar código en la linea (inline), sino que vamos a querer ejecutar código. En esos casos, podemos incluir el leguaje que RStudio debe usar para interpretar dicho código. Por ejemplo 2025-08-07 imprime la fecha actual en R: 2025-08-07 Usaremos un TAB, o 4 espacios para insertar un bloque de código Además de las imágenes quepodemos generar durante el uso mismo de R, podemos incrustar imágenes. Imágenes: ![texto que describe imagen](archivo.png), podemos usar los mismos formatos de imagenes que usa HTML. Estos son al menos GIF, JPG y PNG. Nota: ajustar el tamaño de imágenes es considerado mas avanzado y puede hacerse embebiendo código HTML en markdown. Usaríamos: &lt;figure&gt; &lt;img src=&quot;archivo.jpg&quot; alt=&quot;texto que describe la imágen (visible al pasar el mouse sobre ella)&quot;&gt; &lt;figcaption&gt;CAPTION.&lt;/figcaption&gt; &lt;/figure&gt; 5.5.4 Figuras Podemos incluir figuras en un .Rmd. Esto es posible de muchas maneras, demostraremos 2: Usando la sintaxis de markdown (“nativa”). ![caption](direcion/desde/el/espacio/de/trabajo) Debemos tener super claro el espacio de trabajo desde donde se ejecuta este .Rmd. Lo puedes verificar desde la consola usando getwd(). Usando la librería knitr. Existe una fnucion knitr::include_graphics() que permite un control mas fino de como se muestra la imagen. Incluir imágen externa usando kintr: ```{r chunk de imagen, echo=FALSE, out.width=&quot;50%&quot;, fig.cap=&quot;A nice image.&quot;} knitr::include_graphics(&quot;foo/bar.png&quot;) Ojo, con la ruta de acceso a la imágen! ``` 5.6 MD -&gt; HTML Cuando escribimos en markdown, la gran mayoría de las veces, el interpretador hará una transformación del documento a HTML. Esto ocurre de forma interna, no tienes nada que hacer. Un ejemplo de ello es pinchar en la opcion Visual, para verlo en HTML, o seguir usando la opción Source en la esquina superior izquierda de RStudio. 5.7 Código R En un .Rmd, vamos a confinar el código que queremos que R procese un un chunk. Usaremos tres (3) cremillas inversas. Se pone entre corchetes {} el lenguaje que queremos que RStudio interprete. En general, este será R, pero podría ser otros que tu instalacion permita, como python, o bash. Dentro de los corchetes podemos incluir distintos parámetros con los que se ejecutara (o no) el código. Pero es mas sencillo usar el botón del engranaje: Pinchando en él, puedes ver que se permite ajustar los parámetros básicos, como título del chunk, si es que quieres que se ejecute o si quieres que no muestre los Warnings, etc… parámtros de chunk 2 OJO QUE FINALMENTE: Es dentro del estos chunks donde ocurre la magia, RStudio los interpreta enviándolos a R para que los ejecute. Todo el resto es intepretado como un archivo Markdown que, al ser compilado es enviado a un HTML, PDF o DOCX para poder ser distribuido. 5.8 Recursos Torpedo / CheatSheet R Markdown for scientists data wrangling cheatsheet tablas “bonitinhas” con Kable "],["diapos.html", "Capítulo 6 Diapos 6.1 Capítulo 1: Introducción 6.2 Capítulo 2: Introducción 6.3 Capítulo 3: 6.4 Capítulo 4: 6.5 Capítulo 5: 6.6 Capítulo 6: 6.7 Capítulo 7: 6.8 Capítulo 8: 6.9 Capítulo 9: 6.10 Capítulo 10: 6.11 Capítulo 12: 6.12 Capítulo 13:", " Capítulo 6 Diapos Aquí se afichan las diapos del curso 6.1 Capítulo 1: Introducción Clase 1 - TidyData Clase 1 - 2 6.2 Capítulo 2: Introducción Clase 6.3 Capítulo 3: Clase 6.4 Capítulo 4: Clase 6.5 Capítulo 5: Clase 6.6 Capítulo 6: Clase 6.7 Capítulo 7: Clase 6.8 Capítulo 8: Clase 6.9 Capítulo 9: Clase 6.10 Capítulo 10: Clase 6.11 Capítulo 12: Clase 6.12 Capítulo 13: Clase "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
